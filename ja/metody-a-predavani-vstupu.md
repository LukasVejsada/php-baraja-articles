PPEと入力転送における方法
==============

> id: '843fbfb4-daf2-4c2e-9d94-28d494025b2e'
> slug:
> 	cs: metody-a-predavani-vstupu
> 	ja: ppeto-ru-li-zhuan-songniokeru-fang-fa
> 
> publicationDate: '2020-02-16 20:49:35'
> mainCategoryId: '3e45c55a-a4cd-4745-b1bb-0332702fefbf'
> sourceContentHash: a3e1bca690ed70479ef9807a1f2a1f23

メソッドは、オブジェクトの内部状態を操作したり、オブジェクト同士に影響を与えたりすることができるため、オブジェクトの動作を表します。

実世界でメソッドを表現する
----------------------------------

現実世界の物、例えば猫を考えてみよう。猫にはある性質（名前、色、体重など）があり、それをプロパティで記述し、さらに行動（鳴く、歩く、寝る、など）をメソッドで記述します。世の中にはたくさんの猫がいるので（「雷のように吠える、百万の猫がいるように」）、メソッドは与えられた型のすべてのオブジェクトに等しく適用される一般的なものであることを覚えておくことが重要である。

メソッドの実用化
-----------------------------

言語の構文でいえば、猫のクラスを定義してみよう。

```php
class Cat
{
    public string $name;

    public string $sound = 'ニャー';
}
```

特定の猫のインスタンスを作成した後、例えば音をリストアップするだけでよいのです。

```php
$cat = new Cat;

echo $cat->sound; // "ニャー "と鳴く
```

しかし、書き出すときに、ある方法で音をフォーマットしたい場合はどうすればいいのでしょうか？そうすると、メソッドの出番です。

```php
class Cat
{
    public string $name;

    public string $sound = 'ニャー';

    public function getFormattedSound(): string
    {
        return '音を出している "' . $this->sound . '"!';
    }
}
```

過去からすでに機能の原理をご存知のはずです。クラスは、（プロパティと同様に）定義されたアクセシビリティを持つ関数を直接本体に書き込むことができ、メソッドと呼ばれます。

変数 `$this` は、少し「魔法のように」動作します。現在いるオブジェクトのインスタンスが格納される。もし、プロパティから値を読み出したり、メソッドの中で別のメソッドを呼び出したりしたい場合は、 `$this` 変数上でそれを行えばよいのです。

そして、このメソッドは、プロパティではないことを示すために、古典的な関数としてオブジェクト内部から呼び出されます（最後に括弧が付きます）。

```php
$cat = new Cat;

echo $cat->sound; // "ニャー "と鳴く

echo $cat->getFormattedSound(); // prints 'ニャーと鳴くよ！'を表示します。
```

コンストラクタ - インスタンス生成時に呼び出されるメソッド
--------------------------------------------------

オブジェクトのインスタンスを生成する際、その基本的な状態をどのように設定するか、どのパラメータ（入力データ）が必須であるかを定義する必要があることが多い。

この問題を解決するために、OOP では特別なパブリックメソッド `__construct` が用意されており、任意で実装することができます。

実用例

```php
class Cat
{
    public string $name;

    public string $sound;

    public function __construct(string $name, string $sound)
    {
        $this->name = $name;
        $this->sound = $sound;
    }

    public function getFormattedSound(): string
    {
        return '音を出している "' . $this->sound . '"!';
    }
}
```

コンストラクタを定義することで、インスタンスを生成する際に必ず2つの必須パラメータ（`name`と`sound`）を渡すようにし、オブジェクトを直接設定するようにしました。

コンストラクタは古典的なメソッドなので、挿入されたデータに対して内部で別の処理を行うことができます。例えば、文字列を適切に再フォーマットするなどですが、これについては後述します。

インスタンスの作成もこれまた簡単で、初期パラメータを渡すだけです（クラス名が呼ばれてインスタンスが作成されるところに括弧書きで書かれています）。

```php
$cat = new Cat('ミンダ', 'Vrr');

echo $cat->name; // "ミンダ "と書いてある
echo $cat->sound; // "Vrr "と表示される

echo $cat->getFormattedSound(); // prints 'Vrr'という音を出しています！'と表示します。
```

ゲッターとセッター
-----------------

いくつかのメソッドは `getters` や `setters` と呼ばれます。これらは一般的な方法であり、そう呼ぶのは慣習に過ぎない。メソッドは、オブジェクトにデータを取得したり、挿入したりするために使用されます。主な利点は、データを挿入する前に検証して、場合によっては修正したり、データを拒否してエラーを投げることができることです。

取得可能な各プロパティ（データ検索を可能にしたい）に対して、`get`という単語で始まるゲッターを作成するのが通例である。プロパティがブール値 (`true` または `false`) を返す場合、メソッド名の先頭に `is` という単語を付けるのが通例である。

簡略化した例です。

```php
class Cat
{
    public string $name;

    public function __construct(string $name)
    {
        $this->setName($name);
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function isEmpty(): bool
    {
        return $this->name === '';
    }

    public function setName(string $name): void
    {
        $this->name = trim($name);
    }
}
```

猫のインスタンスを生成する際、コンストラクタにその名前を渡します（これは常に必須です）。しかし、名前を挿入するロジックはコンストラクターとセッター（新しい名前を挿入するメソッド）の両方で共有したいので、コンストラクター内で `setName()` メソッドを呼び出し、確実に名前が挿入されるようにします。

セッターの内部では、<a href="/function-trim">trim()</a>という関数を使って、挿入した文字列の両側から空白を自動的に取り除いています。

出力には `getName()` メソッドを使用することができます。isEmpty()` メソッドを使うと、空っぽかどうかをチェックすることができます。

> 実用的な利点：**。
>
> ゲッターとセッターの大きな利点は、**保証されたデータ型**です。ゲッターが `string` を返すと主張するならば、我々はそれを信頼して常に文字列を得ることができる。
>
> このことは、アプリケーションにとって、ユーザが入力したものは、（`integer`のような互換性のある型を使用する場合）`string`に変換されるか、（`array`のような）型を変換できないというエラーが発生することを意味します。

ゲッターとセッターの最大の付加価値は、特に実用的な場面で評価されるでしょう。

魔法のメソッド `__toString()`
-----------------------------

クラス内では、オブジェクトを文字列として書き出そうとしたときに自動的に呼び出される `__toString()` マジックメソッドを定義することができます。このメソッドは常に文字列を返さなければならない。

実装例です。

```php
class Cat
{
    public string $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    public function __toString(): string
    {
        return 'こんにちは、私は' . $this->name . ';)';
    }
}
```

すると、次のような使い方になります。

```php
$cat = new Cat('ミンダ');

echo $cat; // "こんにちは、ミンダです。"）
```

概要
-------

ここまで、メソッドを定義し、それをオブジェクトのインスタンス内で呼び出す方法を紹介しました。

次回は、メソッドの特性を最大限に活用する<a href="/encapsulation">カプセル化の原則</a>について見ていきます。
