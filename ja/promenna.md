PHPの変数
======

> id: b89774e7-143c-4a8c-8dc6-3b3d2c78d5b7
> slug:
> 	cs: promenna
> 	ja: phpno-bian-shu
> 
> publicationDate: '2019-08-22 20:48:46'
> mainCategoryId: '0e39aee9-2818-480c-8081-e0c2d039bb24'
> sourceContentHash: '23e4d537f18a3b2e1946c79be1aacf52'

このページでは、PHPで変数がどのように動作するかを完全にまとめています。本文はやや専門的な文体で書かれており、初心者の方には十分理解できないかもしれません。もし、完全な基本に興味があるなら、<a href="/first-script">初心者向けチュートリアル</a>と<a href="/principles-of-prominent-script">変数の書き方の原則</a>を読んでみてください。

商品説明
-----

変数はオペレーショナルメモリ内の仮想的な位置で、`name`と`data type`で定義される。データ型の中で、変数はいくつかの `content` を持つことになる。

内部的には、PHPはいわゆるハッシュテーブルとして変数を表現します。つまり、すべての変数は検索が非常に高速なテーブルに格納されているので、各変数にアクセスするのに必要な時間は *ほぼ*一定です。

書き方の例

```php
$a = 10;
$b = '猫';
$c = true;
```

サンプルの各行は、1つの変数の定義を表しています。各変数の名前は、ドル記号 `$` で始まり、その後に名前そのものが続きます。等号を使用すると、変数に値を代入することができます。

内部的には、変数はハッシュテーブルとしてメモリに保存される。

| 名前｜種類｜略語｜値｜の順で表示されます。
|-------|---------|---------|---------|
| $a`｜整数｜int｜`10`｜です。
| $b`｜文字列｜文字列｜`cats`｜。
| $c`｜boolean｜bool｜`true`｜です。

変数型
---------------

変数は、アクセス権や用途によって分類されます。

- <a href="/local-variable">ローカル変数</a>（コンテキスト内、つまり関数やメソッド内で有効）。
- <a href="/global-variable">グローバル変数</a> (スクリプト全体で有効)。
- <a href="/superglobal-variable">スーパーグローバル変数</a>（サーバー環境全体で有効 - 通常はユーザーデータ）。
- <a href="/promenna-variable">変数変数</a>（他の変数への参照（リンク）を含む特殊な変数）です。

* グローバル変数や可変量変数は、コードの可読性を低下させ、アプリケーションの予期せぬ動作を引き起こす可能性があるため、使用すべきではありません。

許容される変数の内容
--------------------------

変数には、現在のデータ型が許す限り、何でも入れることができます。データ型が指定されていない場合は、内容に基づいて自動的に決定されます（エラーが発生する可能性があるため、これは推奨されません）。

データ型は独立して動作するので、ほとんどどんな型でも使うことができる。しかし、何らかのマージ操作を行う場合は、必ず1つのフォーマットへの変換を行わなければならない。

例えば、数字の足し算や掛け算がその良い例です。

```php
$x = 5;       // 整数
$y = 3;       // 整数
$z = $y + $y; // 変数 $z は、複数の変数に基づいて構成されます。
```

この場合、PHP は新しく作成される変数 `$z` がどのようなデータ型になるかという問題に直面することになります。同じデータ型で、かつ操作が可能な場合は、データ型が継承される。

しかし、時には複数のデータ型を使って操作を行うこともあります。

```php
$x = 1;       // 整数
$y = 3.14159; // フロート
$z = $y + $y; // フロート
```

この場合、整数と浮動小数点を融合させる。出力は10進数になるため、floatを使用します。この場合、PHP は **動的な再パーティション化** と呼ばれる処理を行います。

しかし、この挙動は必ずしも当てにならない。例えば、数字と文字列を結合する場合はどうでしょうか。

```php
$x = 256;     // 整数
$y = 'おい、おい！'; // フロート
$z = $y + $y; // ???
```

データ型（重要なものの概要）
--------------------------------------

PHPはインタプリタ型言語であるため、他のプログラミング言語と比較して特殊な点があります。そのひとつが、変数のデータ型を指定する必要がないことです。つまり、各変数はその内容に応じて動的にデータ型を変更します(特に断りのない限り)。それでも、少なくとも基本的なデータ型は知っておいた方がよく、特にアプリケーションを最適化したり、データベースを操作したりするときに便利です。

表記は次のようになります。

```php
$x = (int) 25; // 整数型の変数を作成します。
```

<a href="/datove-typy">データ型の概要</a>です。

データ型の継承
-----------------------

このソースコードの一部しか知らない場合、変数 `$x` はどのようなデータ型になるのでしょうか？

```php
$x = $y;
```

これは変数 `$y` のデータ型に依存し、この変数から値とデータ型が継承されることになります。この場合、変数 `$x` を知らないので、コードの評価を続けることができず、エラーメッセージが投げられます。

ダイナミックオーバーライド
---------------------

次の2つの変数があるとします。

```php
$x = 10;
$y = '10';
```

変数 `$x` と `$y` の内容の違いは何ですか？

変数 `$x` は数値、`$y` は文字列（"1" と "0" を含む）なので、変数をメモリに格納するだけで、値に影響を与える操作を行わないとすると、以下のようになります。例えば、以下の2つのエントリーは同じ結果を返します。

```php
echo $x + 5;	// 15を表示します。
echo $y + 5;	// 15を表示します。
```

2番目のケースは、いわゆる**動的上書き**と呼ばれるもので、変数がそのデータ型を変換して、その変数に対して演算を行うことができるようにするものである。この動作は常に信頼できるものではなく、むしろ初心者の下手なスクリプトを修正するための矯正的な動作である。可能であれば、常に数値を格納するデータ型で数値を書くと、精度が上がり、将来的に利用しやすくなります。

> **注意:** データ型を完全に任意に変換することはできないので、注意が必要です。あるデータ型を他の（互換性のない）データ型に上書きした場合、変換が全く行われないか、元の内容が破損するか、完全に破壊されて別のデータ型に置き換えられる可能性があります。例えば、文字列を整数に書き換えた場合（そして、数値ではない何らかのテキストが変数に格納された場合）、変数には数値の代わりに`1`という値が格納されます。

文字列を配列で表現する
------------------------------

すべての文字列は、内部で文字の配列として保存されます。つまり、各文字はそれぞれ**インデックス**を持ち、参照することができる。インデックスを指定しない場合は、文字列全体が扱われる。

```php
$x = 'PHPでプログラミングをしよう';
$n = 3;

echo $x;		// これは、変数 $x の内容全体を表示します。
echo $x[0];		// これは変数 $x の NULL 文字を表示します。
echo $x[$n];	// これは変数 $x の n 番目の文字を表示します。
```

> **注意:** PHPの数字は0から、つまり0文字は'P'、1文字は'r'です。
>
> さらに、文字はバイト単位で切り替わります。例えば、UTF-8エンコーディングの "no "という文字は2バイト長なので、スクロールしたときに文字列中の文字インデックスと実際の位置が一致せず、2つのインデックスを使って格納することになります。

配列の要素が存在するかどうかは、常に `isset()` 関数で確認する必要があります。

```php
if (isset($x[$n])) {
    echo $x[$n];
}
```

あるいは、三項演算子できれいに書くこともできます。

```php
echo $x[$n] ?? '';
```

変数のコピー
---------------------

次のような変数があるとします。

```php
$q = 'Lorem ipsum, ...';
```

そして、その値を次の変数にコピーする。

```php
$qi = $q;
```

幸いなことに、コピーは行われず、PHP はその値への参照を **ハッシュテーブル** に保存するだけです。実際に値がコピーされるのは、いずれかの変数の値が変更されたときだけです。この動作は、一般に**Garbridge collector**と呼ばれるコンポーネントで処理されます。
