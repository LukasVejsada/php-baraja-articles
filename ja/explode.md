PHP関数 Explode - セパレータで文字列を分割する
==============================

> id: '4dc7cec6-0e96-4a6b-aee8-32c8817ba11e'
> slug:
> 	cs: explode
> 	ja: php-guan-shu-explode-separetade-wen-zi-liewo-fen-gesuru
> 
> perex:
> 	- Rozdělení řetězce na více částí podle oddělovače.
> 	- セパレーターに応じてチェーンを複数に分割する。
> 
> publicationDate: '2019-11-26 11:39:36'
> mainCategoryId: f1b0be9b-de09-4c8a-8338-dc285bed95ec
> sourceContentHash: '66725772be4aae0df8af399e7ce2ba07'

Explodeは、セパレータで文字列を簡単に分割するために使用します。

- 個々の結果は、0から始まる配列として返される。
- の場合、配列は挿入できず、文字列のみが入力されます。
- パース中にデリミタを変更できない、複数のデリミタを選択できない。

| サポート｜PHP 4 以降
|---------------|-----------------|
| 概要｜文字列をセパレータで配列に分割する。
| 必要条件｜なし
| 注意｜配列を挿入することはできず、文字列のみ挿入可能です。

文字列をある簡単なルールに従って分割する必要があることがよくあります。例えば、カンマで区切られた数字の羅列など。

explode()関数は、最初のパラメータとしてセパレータ（文字列の区切り）を、2番目のパラメータとしてデータそのものを受け取るので、この点では優れています。

```php
$cisla = '3, 1, 4, 1, 5, 9';
$parser = explode(',', $cisla);

foreach ($parser as $cislo) {
	echo $cislo . '<br>。';
	// ここでさらに数字を処理することができる
}
```

しかし、数字がカンマで区切られていても、その周りにスペースがある場合はどうでしょうか？

解決策は、最小の共通部分文字列で解析し、その周りの不要な文字（スペースやその他の空白文字）を削除することです。

```php
$cisla = '3, 1,4, 1 , 5 ,9';
$parser = explode(',', $cisla);

foreach ($parser as $cislo) {
     echo trim($cislo) . '<br>。';
     // ここでさらに数字を処理することができる
}
```

この場合、`trim()`関数は文字の周りの空白(スペース、タブ、改行、...)をエレガントに取り除き、きれいなデータのみを提供します。

パースされたエンティティを配列に格納する数を制限する，Limit
--------------------------

> ヒント: 多くの例では、explode()は適切ではなく、正規表現を使用する方がはるかに優れています。

しかし、ある距離までのデータしか解析したくない場合も多く、そのような場合には3番目の（オプションの）パラメータlimitを使用することができます。

例えば、コロンで区切られた構造化データがあり、最初のコロンの後のコンテンツを取得し、他のコロンを無視したいとする。
例

```php
$cas = 'フォーマット："j.n.Y - H:i"';
```

という文字列だけをパースするとしたら。

```php
$parser = explode(':', $cas);
```

この3つの部分文字列を得ることができる（他のケースでは、もっと多くの部分文字列がある可能性がある）。

```php
'形式'
'"j.n.Y - H'
'i"'
```

そのため、取得する要素の数に制限を設けています（場合によっては、それ以外は最後の要素の末尾に追加されます）。

```php
$parser = explode(':', $cas, 2);

// 戻ってきてください。
echo $parser[0]; // 形式
echo $parser[1]; // "j.n.Y - H:i".
```

> **Note:** 不要な引用符は、例えば `trim()` 関数を使って文字列から削除することができます。

```php
echo trim($parser[1], '"'); // 第2パラメータは、削除する文字のマップを指定します。
```

Between, 2つの文字列の間に文字列を取得する
--------------------------

しばしば、他の2つの文字列に囲まれた文字列を取得する必要があります。PHPにはこれを直接行う関数はありませんが、自分で書くことは可能です。

```php
function between(string $left, string $right, string $data): string
{
   $l = explode($left, $data);
   $r = explode($right, $l[1]);

   return $r[0];
}
```

正規表現
--------------------------

文字列の分割や操作は、<a href="/regex">正規表現</a>を使うことで、よりエレガントに行うことができます。

類似機能
--------------------------

- <a href="/function-implode">implode()</a>-配列を連結して文字列にする。

IPアドレスのパース例
--------------------------

```php
$ip = '10.0.0.138';
$parser = explode('.', $ip);
echo $parser[0]; // "10 "と表示される
echo $parser[1]; // "0 "を表示します。
```

変数 `$ip` には入力文字列が格納され、`.` デリミタに従ってパースされた後、配列として返される。解析は、制限が指定されない限り、文字列の終わりまで進められる。

パラメータ
--------------------------

| タイプ｜説明
|---|--------|------|
| 1｜文字列｜分離文字列。
| 2｜文字列｜パースされた文字列。
| 3｜int｜構文解析の限界。このパラメータはオプションである。例

```php
$text = 'PHPは私の大好きな言語です';
$parser = explode('', $text, 1);

echo $parser[0]; // 最初の単語を表示する
echo $parser[1]; // 残りのテキストを表示する
echo $parser[2]; // リミットが設定されているため、何も出力されません。
```

戻り値
--------------------------

戻り値は、解析された文字列を含む配列である。

インデックスは、制限が指定されない限り、0から `X` までの番号が付けられる。

旧バージョンとの相違点
--------------------------

| PHPのバージョン｜説明文
|-----------|-------|
| 5.1.0｜パスの負の制限をサポートしました。
| 4.0.1｜オプションの**limit**パラメータを追加しました。

ヒントと注意点
--------------------------

負の **limit** を用いる場合、文字列の末尾からの要素数が指定される。

例

```php
$str = 'one|two|three|fourの4つ。';

// 正極限
print_r(explode('|', $str, 2));

// 負の制限値 (PHP 5.1 以降)
print_r(explode('|', $str, -1));
```

以下のフィールドが返されます。

```php
Array
(
    [0] => one
    [1] => two|three|four
)

Array
(
    [0] => one
    [1] => two
    [2] => three
)
```
