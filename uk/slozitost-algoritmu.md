Складність алгоритмів
=====================

> id: f0baa25a-4cff-4d3d-b758-5e03f4a8c69c
> slug:
> 	- null
> 	uk: skladnist-algoritmiv
> 
> cs: slozitost-algoritmu
> publicationDate: '2021-08-03 20:40:00'
> mainCategoryId: '1f73dcfa-92a9-4738-ab30-8cbfb00ad23b'
> sourceContentHash: '6269d38b9a2a8d75ec01b569af8b371c'

Кожен алгоритм має свою складність, яку можна виразити в математичних позначеннях. Цей огляд показує типову складність алгоритмів відповідно до розміру вхідних даних (тобто кількості елементів, з якими вони працюють), а також те, які типи алгоритмів підходять для якого типу завдань.

Загалом, для кожного типу проблем існує найкращий спеціалізований алгоритм. Жоден алгоритм не є універсально найкращим, і завжди потрібно знати свій контекст.

Нотація Big O
--------------

Нотація *Big O* використовується для класифікації алгоритмів відповідно до того, як збільшуються вимоги до часу виконання або пам'яті при збільшенні розміру вхідних даних.

На наступній діаграмі показані найбільш поширені порядки зростання алгоритмів, заданих в нотації Big O.

Нижче наведено перелік деяких з найбільш часто використовуваних нотацій Big O та порівняння їх продуктивності щодо різних розмірів вхідних даних.

| Нотація Big O | Складність на 10 елементів | Складність на 100 елементів | Складність на 1000 елементів
| -------------- | ---------------------------- | ----------------------------- | ------------------------------- |
| **O(1)** | 1 | 1 | 1 |
O(log N)** | 3 | 6 | 9 | | 3 | 6 | 9 | | 3 | 6 | 9 | | O(log N)** | 3 | 6 | 9 | | 3
| 10, 100, 1000.
| O(N log N)** | 30 | 600 | 9000
| O(N^2)** 100 | 10000 | 1000000 |
| O(2^N)** ¦ 1024 ¦ 1.26e+29 ¦ 1.07e+301 ¦ ¦ ¦O(2^N)** ¦ 1024 ¦ 1.26e+29 ¦ 1.07e+301 ¦ ¦ ¦O(2^N)
| О(Н!)** ¦ 3628800 ¦ 9.3e+157 ¦ 4.02e+2567 ¦ ¦ ¦О(Н!)** ¦ 3628800 ¦ 9.3e+157 ¦ 4.02e+2567 ¦ ¦ ¦О(Н!)

Складність операцій зі структурами даних
----------------------------------

| Структура даних | Доступ | Пошук | Вставка | Видалення | Коментар
| ----------------------- | :-------: | :-------: | :-------: | :-------: | :-------- |
| Масив 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
| Стопку!
| Черга!
| Пов'язаний список** n n n n n n n n 1 n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n
| **Хеш-таблиця** | - | n | n | n | n | n | У випадку досконалої хеш-функції складність буде O(1) | - | n | n | n | У випадку досконалої хеш-функції складність буде O(1) | - n | n | n | n
| Бінарне дерево пошуку** | n | n | n | n | n | У випадку збалансованого дерева складність буде O(log(n)).
В-дерево** | log(n) | log(n) | log(n) | log(n) | log(n) | log(n) | log(n) | log(n) | ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦
Червоно-чорне дерево** | log(n) | log(n) | log(n) | log(n) | log(n) | log(n) | | ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦
Дерево AVL** | log(n) | log(n) | log(n) | log(n) | log(n) | log(n) | log(n) | log(n) | | ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦
| Фільтр Блума** - | 1 | 1 | - | При пошуку "хибних спрацьовувань

Складність алгоритмів сортування
----------------------------

| Назва алгоритму ¦ Найкращий ¦ Середній ¦ Найгірший ¦ Пам'ять ¦ Стабільна?
| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |
Сортування бульбашками** | n | n<sup>2</sup> | n<sup>2</sup> | 1 | Так | | | 1
Сортування вставкою** | n | n<sup>2</sup> | n<sup>2</sup> | 1 | | | | 1
| **Сортування за вибором** | n<sup>2</sup> | n<sup>2</sup> | n<sup>2</sup> | 1 | | | | | 1
| **Сортування купою** | n&nbsp;log(n) | n&nbsp;log(n) | n&nbsp;log(n) | 1 | | | Немає
Об'єднати сортування** | n&nbsp;log(n) | n&nbsp;log(n) | n&nbsp;log(n) | n&nbsp;log(n) | n | Так | | | Так.
| Швидке сортування** | n&nbsp;log(n) | n&nbsp;log(n) | n<sup>2</sup> | log(n) | Немає | Швидке сортування зазвичай виконується зі складністю стеку O(log(n)).
| Сортування оболонки** ¦ n&nbsp;log(n) ¦залежить від послідовності ¦ n&nbsp;(log(n))<sup>2</sup> ¦ 1 | | | Немає ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦1.
| Сортування за рахунком** | n + r | n + r | n + r | n + r | n + r | Так | r - найбільше число в масиві
| **Радіксне сортування** | n * k | n * k | n * k | n * k | n + k | Так | k - довжина найдовшого ключа
