PHP-функція Explode - розбиття рядка на роздільники
===================================================

> id: '4dc7cec6-0e96-4a6b-aee8-32c8817ba11e'
> slug:
> 	cs: explode
> 	uk: php-funkciya-explode-rozbittya-ryadka-na-rozdil-niki
> 
> perex:
> 	- Rozdělení řetězce na více částí podle oddělovače.
> 	- Розділення ланцюга на декілька частин відповідно до сепаратора.
> 
> publicationDate: '2019-11-26 11:39:36'
> mainCategoryId: f1b0be9b-de09-4c8a-8338-dc285bed95ec
> sourceContentHash: '66725772be4aae0df8af399e7ce2ba07'

Explode використовується для того, щоб легко розділити рядок за допомогою роздільника.

- Він повертає окремі результати у вигляді масиву, пронумерованого з нуля,
- не можна вставити масив, вводиться тільки рядок,
- не можна змінювати роздільник під час синтаксичного аналізу, не можна вибирати декілька роздільників.

| Підтримка PHP 4 і новіших версій
|---------------|-----------------|
| Короткий опис | Розбиття рядка на масив з допомогою роздільника.
| Вимоги | Немає
| Примітка | Неможливо вставити масив, тільки рядок.

Часто нам потрібно розділити рядок за якимось простим правилом. Наприклад, перелік чисел через кому.

Для цього чудово підходить функція explode(), що приймає в якості першого параметра роздільник (розділювач рядка), а в якості другого - самі дані:

```php
$cisla = '3, 1, 4, 1, 5, 9';
$parser = explode(',', $cisla);

foreach ($parser as $cislo) {
	echo $cislo . '<br>';
	// Тут ми можемо обробляти числа далі
}
```

Але що робити, якщо цифри розділені комами, але навколо них є пробіли?

Рішення полягає в розборі по найменшому спільному підрядку, а потім видаленні небажаних символів навколо нього (пробілів та інших пропусків):

```php
$cisla = '3, 1,4, 1 , 5 ,9';
$parser = explode(',', $cisla);

foreach ($parser as $cislo) {
     echo trim($cislo) . '<br>';
     // Тут ми можемо обробляти числа далі
}
```

При цьому функція `trim()` елегантно видаляє пробіли навколо символів (пробіли, табуляції, переноси рядків, ...), видаючи тільки чисті дані.

Ліміт, що обмежує кількість розібраних сутностей в масиві
--------------------------

> ПОРАДА: Для багатьох прикладів explode() не підходить і набагато краще використовувати регулярні вирази.

Однак часто ми хочемо проаналізувати дані лише до певної відстані, і для цього можна використовувати третій (необов'язковий) параметр limit.

Наприклад, нехай у нас є структуровані дані, розділені двокрапкою, де ми хочемо отримати вміст після першої двокрапки та ігнорувати інші двокрапки.
Приклад:

```php
$cas = 'формат: "j.n.Y - H:i"';
```

Якби ми розбирали рядок тільки як:

```php
$parser = explode(':', $cas);
```

Ми отримаємо ці 3 підрядки (в інших випадках їх може бути набагато більше):

```php
'формат'
'"j.n.Y - H'
'i"'
```

Тому ми встановлюємо обмеження на кількість елементів, які можна отримати (і, можливо, всі інші будуть додаватися в кінець останнього елементу):

```php
$parser = explode(':', $cas, 2);

// Повернись:
echo $parser[0]; // формат
echo $parser[1]; // "j.n.Y - H:i"
```

**Примітка:** Непотрібні лапки можна видалити з рядка, наприклад, за допомогою функції `trim()`:

```php
echo trim($parser[1], '"'); // другий параметр задає карту символів для видалення
```

Між, отримання рядка між двома рядками
--------------------------

Часто нам потрібно отримати рядок, який обмежений двома іншими рядками. Безпосередньо в PHP немає функції для цього, але ми можемо написати її самі:

```php
function between(string $left, string $right, string $data): string
{
   $l = explode($left, $data);
   $r = explode($right, $l[1]);

   return $r[0];
}
```

Регулярні вирази
--------------------------

Набагато більш елегантного розбиття і роботи з рядками можна досягти за допомогою <a href="/regex">регулярних виразів</a>, про які я розповідаю на окремій сторінці.

Аналогічні функції
--------------------------

- <a href="/function-implode">Implode()</a> - об'єднання масиву в рядок

Приклад розбору IP-адреси
--------------------------

```php
$ip = '10.0.0.138';
$parser = explode('.', $ip);
echo $parser[0]; // prints "10"
echo $parser[1]; // виводить "0";
```

Змінна `$ip` містить вхідний рядок, який розбирається згідно з розділювачем `.`, повернення - масив. Синтаксичний розбір продовжується до кінця рядка, якщо не вказано обмеження.

Параметри
--------------------------

# | Тип | Опис
|---|--------|------|
| 1-й рядок. Розділювальний рядок.
| 2 рядка. Розбір рядка.
| 3 | int | межа розбору. Це необов'язковий параметр. Приклад:

```php
$text = 'PHP - моя улюблена мова!';
$parser = explode('', $text, 1);

echo $parser[0]; // виводиться перше слово
echo $parser[1]; // виводить решту тексту
echo $parser[2]; // нічого не виводить, тому що встановлено ліміт!
```

Значення, що повертаються
--------------------------

Значення, що повертається - масив з розібраним рядком.

Індекси нумеруються від нуля до `X`, якщо не вказано обмеження.

Відмінності від попередніх версій
--------------------------

| Версія PHP | Опис | Опис
|-----------|-------|
| 5.1.0 | Додана підтримка від'ємного ліміту на пропуски.
| 4.0.1 | Додано необов'язковий параметр **limit**.

Поради та примітки
--------------------------

При використанні від'ємного **обмеження** вказується кількість елементів з кінця рядка.

Приклад:

```php
$str = 'один|два|три|чотири';

// позитивна межа
print_r(explode('|', $str, 2));

// від'ємний ліміт (починаючи з PHP 5.1)
print_r(explode('|', $str, -1));
```

Будуть повернуті наступні поля:

```php
Array
(
    [0] => one
    [1] => two|three|four
)

Array
(
    [0] => one
    [1] => two
    [2] => three
)
```
