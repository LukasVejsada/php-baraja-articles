Базова філософія об'єктно-орієнтованого програмування
=====================================================

> id: c38214d9-8c92-4484-9c31-239d716f2545
> slug:
> 	cs: filosofie-oop
> 	uk: bazova-filosofiya-ob-ektno-orientovanogo-programuvannya
> 
> publicationDate: '2020-01-02 22:21:56'
> mainCategoryId: '3e45c55a-a4cd-4745-b1bb-0332702fefbf'
> sourceContentHash: a3841046b40a039413bacd045f275c68

Об'єктно-орієнтоване програмування - це парадигма, погляд на те, як програмувати. Незабаром ви самі переконаєтеся, що ООП вносить досить принципове спрощення в усі загальні проблеми і труднощі, які знову і знову вирішуються в реальному програмуванні.

Основна ідея
-----------------

Основна ідея об'єктно-орієнтованого програмування полягає в тому, щоб розділити великий додаток (складну задачу) на безліч маленьких частин, які ми можемо вирішити елегантно і незалежно.

Наприклад, якщо ми програмуємо систему бронювання авіаквитків, то це дуже складний проект, який вирішує тисячі кейсів. Якщо ми зможемо розкласти всю складну логіку на багато шарів і частин, ми зможемо легко зрозуміти всю складну систему і запрограмувати окремі підзадачі самостійно.

Практичні переваги ООП та поділу коду на об'єкти
------------------------------------------------

Окрім академічної точки зору, існує багато практичних причин для використання ООП:

- У додатку буде створена <a href="/encapsulation">інкапсуляція</a>, що означає, що дані завжди обробляються в локальному контексті, яких небагато, тому нам не доведеться думати про весь додаток відразу.
- Ми можемо розбити додаток на сотні тисяч маленьких частин, які можуть розроблятися різними людьми паралельно, і просто організувати спільний інтерфейс.
- Ми можемо дивитися на додаток з точки зору різних рівнів (абстрактно на цілі модулі, або локально на конкретні функції, що вирішують певний алгоритм).
- Під час налагодження програми (debugging) ми можемо покроково виконувати програму, опускати або замінювати деякі частини.
- Ми можемо краще застосовувати **патерни проектування** і таким чином запобігати помилкам і складнощам у коді до того, як вони з'являться.

Особисто я не можу уявити собі команди, в яких більше однієї людини програмує по-іншому.

> Примітка: **Примітка:**.
>
> Використання об'єктів трохи збільшує навантаження на пам'ять і процесор комп'ютера, тому це трохи знижує продуктивність програми. У реальному середовищі, однак, це не має значення, тому що перепрограмування програми на об'єкти дійсно втрачає деяку продуктивність (зазвичай одиниці відсотків), але це економить час програмістів (зазвичай від десятків до сотень відсотків). Людський час завжди набагато дорожчий (і дуже обмежений), ніж час комп'ютера.
>
> Не забувайте також, що ООП приносить велике спрощення для всієї програми і дозволяє виконувати великі програми за розумний проміжок часу. Без об'єктів було б практично неможливо запрограмувати велику кількість складних додатків.

Зв'язок з реальним світом
-------------------------

Основна мета ООП при розробці програмного забезпечення полягає в тому, щоб максимально імітувати властивості, поведінку та принципи реального світу. Об'єкти в ООП представляють собою реальні сутності. Такий спосіб мислення дозволяє нам будувати величезні складні системи, які можна добре зрозуміти, вирішувати реальні проблеми всередині себе так, як вони вирішувалися б без комп'ютера, а принципи можна пояснити реальним людям.

Наприклад, якщо ми реалізуємо додаток для управління контентом, то всю внутрішню логіку має сенс викласти в багатьох реальних сутностях (стаття, автор, категорія) і будувати сесії не за штучно згенерованими ідентифікаторами записів (як це прийнято робити в базах даних), а за реальними взаємозв'язками.

Приклад конкретної реалізації:

```php
class Article
{
    private Author $author;

    /** @var Category[] */ */ */ */ */ */ */ */ */ */ */ */ */ */
    private array $categories;

    private string $title;
}

class Author
{
    private string $name;
}

class Category
{
    private string $name;
}
```

Як бачимо, клас `Article` містить не тільки технічні параметри, такі як ідентифікатор запису з автором, а є реальною прив'язкою до сутності Author, яка знову ж таки має свої властивості.

Пояснення щодо конкретної реалізації та синтаксису див. у <a href="/uvod-do-oop">вступному посібнику</a>.
