Шифр Цезаря - як він працює
===========================

> id: '662dd627-c106-406e-ad6a-7ae9a492ad92'
> slug:
> 	cs: cesarova-sifra
> 	uk: sifr-cezarya-yak-vin-pracyue
> 
> publicationDate: '2019-08-23 15:43:02'
> mainCategoryId: '3666a8a6-f2a3-405d-8263-bd53c4301fb3'
> sourceContentHash: '892ad0746be469b5cdbb4de72d8e85b9'

> Попередження:** Ця стаття була написана багато років тому і деяка інформація може бути застарілою або невірною. Будь ласка, майте це на увазі при читанні.

Шифр Цезаря є однією з найпростіших функцій хешування. Свого часу він був практично незламним, але в епоху сучасних комп'ютерів для його зламу потрібно лише кілька десятків секунд, а то й хвилин. В його основі лежить ключ, відповідно до якого повідомлення зашифровується, а потім відповідно до якого його можна знову розшифрувати. Тому ключ є таємницею. У момент шифрування повідомлення можна буде побачити і воно нічого не означатиме (просто нагромадження символів). Єдиний спосіб зламати шифр - вгадати ключ.

Ключ
--------------------------

Ключем може бути будь-яке ціле число, яке має менше цифр, ніж саме повідомлення. Зазвичай дається 3 допустимі цифри (таким чином, існує 999 комбінацій). Кожна додаткова цифра підвищує рівень безпеки. Для того, щоб 2 сторони могли спілкуватися, обидві сторони повинні знати цей секретний ключ (тобто вони повинні якимось чином безпечно передати його один одному). Якщо ключ відомий їм, а не іншим, то повідомлення можна поширювати навіть незахищеним способом і потенційно не компрометувати його зміст, оскільки потенційний зловмисник не знає процедури отримання повідомлення назад.

Для демонстрації я буду використовувати ключ **123**, зазвичай використовується якесь інше випадкове число, яке, як передбачається, не так легко вгадати.

Процедура шифрування
--------------------------

В основі принципу лежить ідея заміни символів повідомлення на інші за допомогою ключа. Я називаю це "зміною характеру".

Наприклад, нехай у нас є повідомлення, яке ми хочемо зашифрувати:

```php
TAJNA ZPRAVA
```

Тепер присвойте кожному символу номер. Як правило, за алфавітом (його порядковим номером). Я буду використовувати англійський алфавіт, тому цей ряд символів:

```php
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
```

Якщо присвоїти кожному символу номер, то вийде щось на кшталт:

```php
20-1-10-14-1   26-16-18-1-22-1
```

Тепер настає ключовий момент. Беремо кожне окреме число і додаємо до нього ключ. Виділяю кольором, що і де я додав:

`1 2 3`

```php
21 3 13 15 3   3 17 20 4 23 3
```

Зверніть увагу, що коли я шифрую символ **Z**, то пишу цифру 3. Це пов'язано з тим, що **Z** є останнім символом алфавіту, тому коли він доходить до кінця, то знову починає відлік з початку рядка.

Передача повідомлення
--------------------------

Тепер ми можемо передавати меседж у будь-який спосіб. Іноді навіть публічно. Інші побачать лише нелогічний ряд цифр, тому, ймовірно, навіть не здогадаються, що це якийсь шифр. Безпека посилюється і самим ключем, який є секретним. Іноді доречно передавати повідомлення у вигляді серії цифр, іноді доречно перетворити ці цифри в символи (знову ж таки, дотримуючись того ж алфавітного ряду), а потім передати послідовність символів. Багато що залежить від обставин. В цілому, однак, числова послідовність є кращою, оскільки мало хто запідозрить, що це закодоване повідомлення.

Розшифровка у одержувача
--------------------------

Одержувач розшифровує за такою ж процедурою. Він бере кожен окремий символ і віднімає цифри відповідно до ключа, а потім перетворює отримані значення назад в символи, використовуючи алфавіт. Це просто зворотна процедура шифрування. Важливо знати **ключ** і **набір символів** - тобто, як послідовно йдуть символи.

Розкриття та дешифрування
--------------------------

Єдиною можливою процедурою зламу є перебір усіх можливих комбінацій усіх потенційних ключів. Якщо ми не знаємо довжину ключа, то весь процес ще більше ускладнюється. Але в цілому, сучасні комп'ютери можуть перебрати близько 100 ключів за 1 секунду, тому на злам випадкового ключа довжиною 3 символи потрібно близько хвилини.

Однак, якщо ключ такий самий довгий або довший за вихідне повідомлення, його неможливо зламати, оскільки кожен окремий символ має свій власний ключ, тому всі комбінації повинні бути випробувані для кожного символу.

Якби у мене було повідомлення "**ПРИЙНЯТИ ПОВІДОМЛЕННЯ**", то воно було б довжиною 11 символів (пробіли не рахуються). Якби я хотів ключ довжиною також 11 символів, а я використовував 26-символьний рядок англійського алфавіту, то існує **11^26** = 1.191817654*10²⁷ комбінацій, середньостатистичний комп'ютер зламав би цей ключ за 1.310999419×10²⁶ секунд = 10^20 днів :)
