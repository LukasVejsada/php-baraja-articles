Методи у сфері ОЗ та передачі виробничих потужностей
====================================================

> id: '843fbfb4-daf2-4c2e-9d94-28d494025b2e'
> slug:
> 	cs: metody-a-predavani-vstupu
> 	uk: metodi-u-sferi-oz-ta-peredaci-virobnicih-potuznostej
> 
> publicationDate: '2020-02-16 20:49:35'
> mainCategoryId: '3e45c55a-a4cd-4745-b1bb-0332702fefbf'
> sourceContentHash: a3e1bca690ed70479ef9807a1f2a1f23

Методи відображають поведінку об'єкта, оскільки дозволяють працювати з його внутрішнім станом, а також впливати на об'єкти один з одним.

Представлення методів у реальному світі
----------------------------------

Візьмемо будь-який реальний об'єкт, скажімо, кішку. Кішка має певні властивості (ім'я, колір, вага, ...), які ми описуємо за допомогою властивостей, а також поведінку (нявкання, ходьба, сон, ...), яку ми описуємо за допомогою методів. Оскільки котів на світі багато ("І тому я гавкаю, як грім, хай буде мільйон котів"), то важливо пам'ятати, що метод - це щось загальне, що однаково застосовується до всіх об'єктів даного типу.

Практична реалізація методу
-----------------------------

З точки зору синтаксису мови визначимо клас для кота:

```php
class Cat
{
    public string $name;

    public string $sound = 'Мяу!';
}
```

Створивши екземпляр конкретного кота, ми можемо просто перерахувати, наприклад, звук:

```php
$cat = new Cat;

echo $cat->sound; // каже "Мяу".
```

Але що робити, якщо ми хочемо певним чином відформатувати звук при його запису? Тоді в гру вступають методи:

```php
class Cat
{
    public string $name;

    public string $sound = 'Мяу!';

    public function getFormattedSound(): string
    {
        return 'Я видаю звук"' . $this->sound . '"!';
    }
}
```

Ви, мабуть, вже знаєте принцип роботи функцій з минулого. Класи дозволяють записувати функцію безпосередньо в її тіло з визначеною доступністю (як у випадку з властивостями) і називаються методами.

Змінна `$this` поводиться трохи "магічно". У ньому зберігається поточний екземпляр об'єкта, в якому ми зараз знаходимося. Якщо ми хочемо прочитати значення з властивості або викликати інший метод всередині методу, нам достатньо зробити це через змінну `$this`.

Потім метод викликається зсередини об'єкта як класична функція (з круглими дужками в кінці), щоб сказати, що він не є властивістю:

```php
$cat = new Cat;

echo $cat->sound; // каже "Мяу".

echo $cat->getFormattedSound(); // виводить 'I'm making a "Meow" sound!'
```

Конструктор - метод, що викликається при створенні екземпляру
--------------------------------------------------

При створенні екземпляру об'єкту часто потрібно визначити, як задати його базовий стан та які параметри (вхідні дані) є обов'язковими.

В ООП для вирішення цієї проблеми є спеціальний загальнодоступний метод `__construct`, який ми можемо реалізувати добровільно і він викликається завжди і тільки при створенні екземпляру.

Практичний приклад:

```php
class Cat
{
    public string $name;

    public string $sound;

    public function __construct(string $name, string $sound)
    {
        $this->name = $name;
        $this->sound = $sound;
    }

    public function getFormattedSound(): string
    {
        return 'Я видаю звук"' . $this->sound . '"!';
    }
}
```

Визначивши конструктор, ми зробили так, що при створенні екземпляру ми завжди повинні передавати 2 обов'язкових параметри (`name` та `звук`) і об'єкт буде задаватися безпосередньо.

Оскільки конструктор є класичним методом, він може робити щось інше всередині зі вставленими даними. Наприклад, переформатувати рядок відповідним чином, але про це пізніше.

Створити екземпляр після цього знову легко, потрібно лише передати початкові параметри (вони записуються в круглих дужках до імені класу, де викликається ім'я класу і створюється екземпляр):

```php
$cat = new Cat('Міндо.', 'Вррр');

echo $cat->name; // Тут написано "Мінда".
echo $cat->sound; // виводить "Vrr"

echo $cat->getFormattedSound(); // виводить 'I'm making a "Vrrr" sound!'
```

Геттери і сеттери
-----------------

Деякі методи називаються "геттери" і "сеттери". Це звичайні методи, це просто умовність, що ми їх так називаємо. Методи використовуються для отримання та вставки даних в об'єкт. Основна перевага полягає в тому, що ми можемо перевірити дані перед тим, як вставити їх, і, можливо, виправити їх або відхилити дані і видати помилку.

Для кожної властивості, яка може бути отримана (ми хочемо забезпечити можливість отримання даних), прийнято створювати геттер, що починається зі слова `get`. Якщо властивість повертає логічне значення (true або false), то початок імені методу прийнято називати словом is.

Спрощений приклад:

```php
class Cat
{
    public string $name;

    public function __construct(string $name)
    {
        $this->setName($name);
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function isEmpty(): bool
    {
        return $this->name === '';
    }

    public function setName(string $name): void
    {
        $this->name = trim($name);
    }
}
```

При створенні екземпляру cat ми передаємо його ім'я в конструктор (що завжди є обов'язковим). Однак, оскільки ми хочемо розділити логіку вставки імені як для конструктора, так і для задатчика (методу вставки нового імені), ми викликаємо метод `setName()` всередині конструктора, щоб гарантувати, що ім'я буде вставлено.

Всередині сеттера використовуємо функцію <a href="/function-trim">trim()</a>, яка автоматично видаляє пробіли з обох сторін вставленого рядка.

Для виведення можна використати метод `getName()`. Для перевірки на порожнечу можна використовувати метод `isEmpty()`.

> **Практичні переваги:** *Практичні переваги:** *Практичні переваги
>
> Величезною перевагою геттерів та сеттерів є **гарантовані типи даних**. Якщо геттер стверджує, що повертає "рядок", ми завжди можемо на нього покластися і завжди отримати рядок.
>
> Сеттер у своїй реалізації також стверджує, що приймає "рядок", що означає для програми, що незалежно від того, що вводить користувач, він або отримає вхідні дані у вигляді "рядка" (якщо він використовує сумісний тип, наприклад, "ціле число"), або отримає помилку, що тип не може бути перетворений (наприклад, "масив").

Найбільша додана вартість геттерів та сеттерів буде оцінена саме в практичному використанні.

Магічний метод `__toString()`
-----------------------------

У класі можна визначити магічний метод `__toString()`, який автоматично викликається при спробі вивести об'єкт у вигляді рядка. Метод завжди повинен повертати рядок.

Приклад реалізації:

```php
class Cat
{
    public string $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    public function __toString(): string
    {
        return 'Привіт, я' . $this->name . ';)';
    }
}
```

Застосування полягає в наступному:

```php
$cat = new Cat('Міндо.');

echo $cat; // Написано: "Привіт, я Мінда ;)"
```

Резюме
-------

Ми показали, як визначати методи та викликати їх в екземплярі об'єкту.

Наступного разу ми розглянемо <a href="/encapsulation">принцип інкапсуляції</a>, який в повній мірі використовує властивості методів.
