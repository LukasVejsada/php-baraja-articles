Як зламати функцію md5
======================

> id: '9e678fcc-3d5e-46a3-9c3f-c1eb3d1ad367'
> slug:
> 	cs: lamani-md5
> 	uk: yak-zlamati-funkciyu-md5
> 
> publicationDate: '2019-08-23 15:33:10'
> mainCategoryId: '3666a8a6-f2a3-405d-8263-bd53c4301fb3'
> sourceContentHash: '4e176a09e43dbf12e131103be6a9cf4f'

MD5 є дуже поширеною функцією для обчислення хешів.

Початківці часто використовують його для <a href="/hashovani">хешування паролів</a>, що не є гарною ідеєю, оскільки існує багато способів відновити оригінальний пароль.

Ця стаття описує конкретні методи, як це зробити.

Часова складність
----------------

Вся безпека побудована на тому, що перебір всіх паролів займає непропорційно багато часу. Що ж, так і має бути. Проблема алгоритму `md5()`, зокрема, полягає в тому, що це дуже швидка функція. На звичайному комп'ютері не проблема обчислити понад мільйон хешів за секунду.

Якщо ми зламуємо пароль, перебираючи комбінації по черзі, то це **атака грубої сили**.

Методи крекінгу
----------------

Є кілька стратегій:

- Послідовний метод спроб і помилок (атака грубою силою)
- Тестування словникових паролів
- Райдужні таблиці (попередньо розрахована хеш-база даних)
- Пошукові запити в Google
- Попадання колізій в алгоритм

Існує набагато більше методів, в цій статті описані лише найпоширеніші з них.

Стратегії злому грубою силою
-----------------------------

Всі комбінації букв, цифр та інших символів випробовуються по черзі.

Згенеровані спроби хешуються одна за одною і порівнюються з оригінальним хешем.

Так, наприклад:

```php
aaaaaaabaaacaaadaaaeaaaf...
```

Проблема цієї атаки полягає в самому алгоритмі `md5()`, якби ми перебирали тільки малі літери англійського алфавіту і цифри, то на перебір всіх комбінацій на загальнодоступному комп'ютері пішли б щонайбільше десятки хвилин.

Тому важливо обирати довгі паролі, бажано випадкові, зі спеціальними символами.

Стратегія словникової атаки
----------------------------

Зазвичай люди обирають слабкі паролі, які існують у словнику.

Якщо скористатися цим фактом, то можна швидко відкинути малоймовірні варіанти на кшталт `6w1SCq5cs` і натомість вгадувати вже існуючі слова.

Крім того, з попередніх витоків паролів великих компаній ми знаємо, що користувачі обирають велику літеру на початку пароля та цифру в кінці. Подивимось - чи є це у вашому паролі? :)

Веселкові таблиці - попередньо розрахована база даних
--------------------------------------

Оскільки одному паролю завжди відповідає один і той же хеш, легко перерахувати величезну базу даних, в якій паролі будуть шукати в першу чергу.

Насправді, пошук завжди на порядки швидше, ніж перебір хешів знову і знову.

Крім того, для більших витоків даних, паролі можуть бути паралельно хешовані таким чином і, наприклад, 10% всіх паролів користувачів можуть бути швидко відновлені.

Хорошою базою паролів є, наприклад, <a href="https://crackstation.net/">Crack Station</a>.

Пошук в Google
-------------------

Багато простих паролів відомі безпосередньо Google, оскільки він індексує сторінки, які містять хеші.

Я завжди використовую Google як перший варіант. :)

Пошук колізій в алгоритмі
--------------------------

<a href="https://cs.wikipedia.org/wiki/Dirichlet%C5%AFv_princip">Принцип Діріхле</a> описує, що якщо ми маємо набір хешів, які завжди мають довжину 32 символи, то існує як мінімум 2 різних пароля по 33 символи (один довший), які генерують один і той же хеш.

На практиці шукати колізії не має сенсу, але іноді автор заявки сам полегшує собі завдання, перераховуючи колізії.

Наприклад:

```php
$password = 'пароль';

for ($i = 0; $i <= 1000; $i++) {
    $password = md5($password);
}

echo $password; // 1000x хешування через md5()
```

У цьому випадку має сенс вгадувати колізію, а не вихідний хеш.

Вип'ємо за розлив!
