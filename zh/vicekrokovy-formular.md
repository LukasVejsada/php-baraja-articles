多年的形式
=====

> id: '2abacddd-8a6b-4d25-a387-603fc7abc333'
> slug:
> 	cs: vicekrokovy-formular
> 	zh: duo-nian-de-xing-shi
> 
> publicationDate: '2019-09-16 09:30:19'
> mainCategoryId: a23332c0-a233-4093-abd7-85b1b00a383b
> sourceContentHash: '69cb85c856478d588b96e9db9e695d97'

有时我们需要将表格分成几个部分（页面），分别处理，然后将它们组合成一个结果。

本文介绍了实现这一目标的方法和设计模式。

> **注意：**
>
> 将一个表格分割成多个步骤的问题非常复杂，尤其是如果你想把它做好。在我的一生中，我遇到了许多方法，我将在此讨论。有些方法看起来很吸引人，但很天真，只在特定情况下有效。对于每一种方法，我都会描述它在什么时候有意义，哪些方法没有意义。

理论解决方案的设计
-------------------------

通常情况下，目标是在第一页的第一个表单中获取基本数据，对其进行验证，然后将其保存在 "某个地方 "并显示下一页。

当用户到达最后一页时，需要提交整个表格并处理输入。

在每个步骤中，重要的是要始终仔细验证所有的数据，并允许用户随意跳回页面，以便他们在遇到错误时可以纠正回来的数据。此外，如果要根据已经获得的数据有条件地呈现表格，这也是一个非常苛刻的过程。

执行表格本身
--------------------------------

我们可以自己用纯HTML实现各个表单，然后在PHP中处理，或者使用现成的解决方案，如<a href="https://doc.nette.org/cs/3.0/forms">Nette表单</a>。

> **生活中的例子：**
>
> 很多时候，新手程序员给我发电子邮件，问一些看似简单的问题，而这些问题都有现成的解决方案。例如，特别是关于PHP中的表单处理。
>
> 我总是建议完全跳过手工处理，而使用现成的解决方案。在现实中，要正确地实现，例如，验证输入的电子邮件和2个字段内的2个密码是否匹配，而我们要根据用户的数据重定向到预先填写的表格，并在出现错误时提供错误信息，这是非常复杂的。
>
> 因为人们**不知道他们不知道他们不知道**，所以他们不愿意投入1个小时的时间来学习一个现成的解决方案来解决99.99%的问题，而是喜欢选择自己的解决方案，他们花了几十个小时来调试，仍然存在表单不工作、抛出错误、有安全漏洞、不能保护输入的数据的情况。

所以这一步的目标是在不同的URL上实现几个页面，这些页面将包含空白表格。

我建议独立实现每个表单（原子），并在不同的应用层处理状态传递。原因是每个表单在实践中都会以不同的方式处理数据验证，以不同的方式编写其输出，以不同的方式处理错误，而且我们很可能想随着时间的推移进行扩展或改变，所以我们不需要知道整个过程的背景，也不需要改变几十个网站来这样做。

国家转移
---------------

在处理第一个表单时，我们希望首先验证收到的数据，如果数据正确，则将用户重定向到第二步。将重定向作为HTTP重定向处理是一个好主意，因为很容易发生数据无效的情况，在这种情况下，我们要将用户返回到第一个表单，而不是下一步。

我们基本上可以用4种方式存储状态。

**不建议：**

- **不要存储在任何地方**，完全在URL中传输。 这样做的缺点是用户可以改变已经在URL中发送的数据，从而伪造输入。另外，我们可以在URL中披露敏感信息，如密码。
- **连续添加到<a href="/sessions">sessions</a>**，也就是说，按键逐步将新获得的数据插入该领域。这样做的缺点是，如果应用程序出错，用户会被卡住，无法以任何方式解决这个错误（除了删除cookies，这对大多数人来说是非常困难的），再加上未完成的表格，有可能数据仍然是预先填入的，可以被其他人看到。然而，更糟糕的情况是，如果会话的有效期很短（比如5分钟），用户在填写最后一步时失去了第一步的数据......这就会变得很烦人。

**推荐：**

- **存入数据库并传递标识符**。第一次提交表单时，我们将所有收集到的数据存储在一个数据库表中，并生成一个随机的标识符（比如一个10个字符的长字符串），作为参数在页面之间传递。这样做的好处是，在处理任何表格时，我们可以将新检索和验证的数据直接写入表中，在发生故障时，我们有解析过的表格的物理备份，可以对它们采取行动。例如，当一个订单未完成时，我们可以向用户发送一封电子邮件，告诉他们没有完成，增加销售的机会。
- 保存到当前登录的账户**的工作方式与通过ID转发完全相同，只是我们使用的不是随机标识符（token），而是当前登录的用户的ID（如果有的话）的会话。 其优点是我们可以在未来任意向用户显示预先填充的数据。

总结
-----

上述解决方案中没有一个是完美的，也没有一个是唯一正确的。我自己在研究多步骤的解决方案时，会结合多种方法。例如，通常情况下，我把购物车作为一个数据库表来解决，我把已经收集到的数据分配给它，并把它绑定到一个用户（如果他已经登录）或一个会话（如果他没有登录，我们还不认识对方）。
