PHP中的条件 - IF() {...} - 分支选项
===========================

> id: '3e4b81bb-a8bb-4e99-8842-e76f1658a371'
> slug:
> 	cs: if
> 	zh: php-zhong-de-tiao-jian-if-fen-zhi-xuan-xiang
> 
> perex:
> 	- 'Podmínky, logické výrazy, booleovská logika a možnosti větvení PHP scriptů. Vyhodnocování logických výrazů a operátory. Možnosti skládání výrazu.'
> 	- 条件、布尔逻辑、布尔逻辑和PHP脚本分支选项。评估布尔表达式和运算符。表达式折叠选项。
> 
> publicationDate: '2019-11-26 11:55:09'
> mainCategoryId: '6cbbbf59-9bbd-4ca3-a6c3-eb204a2f8070'
> sourceContentHash: '0d8a00928bcfa899d4e6dbf6c067394e'

> **注意：**这篇文章对一些初学者来说可能有点乱，因为它假设了对PHP的基本理解。如果你对条件的作用感兴趣，请阅读<a href="/conditions">关于初学者课程中的条件</a>。

| 支持：|所有版本：PHP 4、PHP 5、PHP 7
|-------------------|----------|
| 简要描述: | 一个或多个报表的验证
|类型: |<a href="/statements-and-functions">语句，结构</a>（不是函数）。

描述
-----

通常你需要确定一个等式是否成立或一个语句是否为真，这就是条件的作用。PHP和许多其他语言（尤其是C语言）一样使用以下语法。

```php
if (/* 逻辑声明 */) {
    // 构建
}
```

每个逻辑表达式都有一个`TRUE`（真）或`FALSE`（假）的值，没有其他选项。

比较变量`$x`是否大于变量`$y`的例子。

```php
$x = 10;
$y = 5;

if ($x > $y) {
    // 如果条件为真，脚本的这一部分将被执行。
} else {
    // 如果条件不适用，脚本的这一部分将运行。
}
```

条件结构在圆括号内有一个强制性的内容，其中给出了要测试的表达式，由运算符组成（概述如下），多个表达式可以使用逻辑运算符连接（概述如下）。

此外，该条件包含两个可选的语句块。

- 如果条件成立
- 如果该条件不成立

出于实际原因，当条件为真时，总是至少包括第一个语句块，否则测试表达式就没有意义了。

分号和括号的使用
--------------------------

一般来说。
- **圆括号**用于分隔逻辑表达式（其他圆括号可以陷入以实现更复杂的表达式）。
- 复数**括号用于限定一个命令和函数块的边界。
- 中间的***不是用来表示一个条件（命令块由复合括号划定），而是用来分隔条件中的各个命令）。

唯一可能使用分号的符号（除了使用**endif**结构时）。

```php
if ($x > $y);
```

然而，这样的条件是没有意义的，因为在这两种情况下，比较的结果将被丢弃，属于该条件的语句不会被执行。

替代记号
--------------------------

在某些情况下，"如果 "结构可以在省略复合括号的情况下使用。这只有在以下情况下才能实现。

- 如果我们在条件中只执行一条语句。
- 如果我们用冒号和endif来代替复合括号。
- 如果我们使用 "线内 "符号。

更详细的信息，请参见以下3章。

> **`1.只有一个命令~缩写的语法`**

如果你在创建一个条件时只想执行一个结构（语句），你可以使用经典的复合括号符号。

```php
if ($x > 10) { $y = $x; }
```

或者我们可以省略括号。

```php
if ($x > 10) $y = $x;
```

然而，这种行为只适用于紧邻该条件的一个命令。

一个更好的例子（只有`$y = $x`结构体是有条件执行的，其余的总是执行）。

```php
$x = 5;
$y = 3;
$z = 10;
if ($x > $y)
$y = $x;
$x = 3;
```

> **`2.冒号和endif;`***

```php
if (/*表达式 */):
    konstrukt;
    konstrukt;
    konstrukt;
endif;
```

然而，这种符号早已被认为是过时的，因为当多个条件浸入自身时，它的方向性会降低。

> **注：**我想指出的是，这种风格也受到一些人的喜欢，比如余秋雨（<a href="https://www.jakpsatweb.cz/php/php-tahak.html#vetveni">见他的文章</a>）。上帝不允许你在什么地方使用这个。

> **`3.三元表达式~单行 "行内 "符号`**

偶尔做一个简单的线上比较和其他动作（例如，在定义一个新变量的同时）是很有用的。如果我们只想执行一条语句，即使在保持尽可能简单的情况下，整个程序也可以减少到一行。

```php
$x = 5;
$isBiggerThanTwo = ($x > 2 ? true : false);

//甚至更短。

$isBiggerThanTwo = ($x > 2);

//或不含括号。

$isBiggerThanTwo = $x > 2;
```

操作员表
-----------------

条件中使用了两种类型的运算符。

- **比较性** ~ 他们比较一个特定的关系。
- **逻辑性**~结合多个表达式来创建复杂的条件。

比较运营商
-----------------------

| 运营商 | 意义 |
|----------|----------|
| `==` | 等于
| `===` | 等于并且具有相同的数据类型
| `! =` | 不等于
| `>=` | 等于或大于
| `<=` | 等于或小于
| `>` | 大
| `<` | 少

例子（当"$x不是5 "时有效）。

```php
if ($x != 5) { ... }
```

逻辑运算符
--------------------

| 运营商 | 替代方案 | 意义 | 真时。
|-----------|--------------|----------------|--------------------------------------------
| `&&` | 和 | 同时 | 两个值都是真的
| `|||||||或||至少有一个值为真
| `^^` | XOR | 排他性OR | 至少有一个是真的或假的，但绝不是两个都是。
| `!` | *doesn't* | 表达式的否定性 | `true`当`false`，反之亦然
| `()` | *不 * *表达式否定|取决于情况

一个更复杂的例子。

```php
$x = 5;
$y = 3;
$z = 8;
if ($x > 0 && !($y != 2 && $z == $x) || $z > $y) { ... }
```

省略逻辑和比较运算符
---------------------------------------------

通常我们可以省略任何一个运算符（甚至是两个），但是我们决不能忘记正确的使用规则，以使产生的表达式有效。

一般来说，当测试一个没有运算符的表达式时，我们测试它的值是否为`TRUE`或非空（例如，它包含一个非零的数字，一个非空的字符串，...）。

例子。

```php
$x = 5;
$y = 3;
$z = 8;

if ($x) { ... }         //通过，因为$x不是空的
if ($x && $y) { ... }   //通过，因为$x和$y不是空的
if (!$x) { ... }        //失败，因为TRUE被否定了
if (isset($z)) { ... }  //通过，因为变量$z存在
```

但棘手的情况可能会出现，尤其是当。
- 我要求`如果($x)`，而变量`$x`包含零(`0`)，则条件不满足。
- 或者变量`$x`包含字符串``0``（数字0），因为它溢出到0，所以表达式不是真的。
- 在条件中，有一个函数总是返回一些非空的字符串，因为这样条件总是为真。
- 或者，如果我们正在检查用户的输入，并且他返回了"'false'"作为一个字符串，那么同样条件是真的，因为这个字符串是非空的。

我推荐一个简单而有效的解决方案--要求返回的字符数。如果字符串为空（或变量不存在），则返回零字符，条件不满足。简单的例子。

```php
$x = '0';
if ($x) { ... }			// 条件通常不适用
if (strlen($x)) { ... }	// 条件是有效的，因为$x包含1个字符
```

接下来，我们可以使用`isset()`函数测试一个变量的存在。

字符串比较
-----------------

发现琴弦是相同的很容易。

```php
$a = '猫咪';
$b = '猫';

if ($a === $b) {
    // 如果这些字符串是相同的
} else {
    // 如果字符串不同
}
```

重要的是，要适当关注数据类型，以防该条目可能等同于其他条目。

例如，空字符串`$a = '';`与字符串`NULL`不同：`$b = NULL;`。我们需要做出这样的区分，例如，因为数据库中的值不存在或为空是有区别的。

```php
$a = '';
$b = null;

if ($a == $b) {
    // 它将被评估为TRUE，因为
    // 数据类型被转换。
}

if ($a === $b) {
    // 执行更严格的验证
    // 而它不会通过，因为它是一个不同的
    //内容和不同的数据类型，因此
    // 这段代码将永远不会运行。
}
```

在比较字符串时，忽略空白（不可见）字符也是一个好主意，如空格、制表符和换行符。例如，在输入密码并将其传递给散列函数时，这很有用。

```php
$password = '81dc9bdb52d04dc20036dbd8313ed055'; // 1234
$userPassword = '1234';

if (md5(trim($userPassword)) === $password) {
    // trim()函数会自动删除空格。
}
```

未知的（不存在的）价值？
--------------------------

有时会发生值不存在的情况（既不是`TRUE`也不是`FALSE`），它主要是从数据库中获得的值（例如，我们要求一个不存在的列），在这种情况下，将返回数据类型`NULL`。

一般来说，`NULL'被评估为`FALSE'，即条件不适用。然而，这种行为并不总是方便的，因为一个不存在的值并不一定意味着没有记录。

> 实践中的例子。我们有一个用户档案，我们查询用户的网页。不是所有的用户都需要有一个网页，所以在这种情况下会返回`NULL'，但用户仍然存在。所以在这种情况下，我们更应该使用`isset()`函数来测试变量的（不）存在，而不是根据特定的值来做结论。
