PHP函数Explode - 通过分隔符分割字符串
=========================

> id: '4dc7cec6-0e96-4a6b-aee8-32c8817ba11e'
> slug:
> 	cs: explode
> 	zh: php-han-shuexplode-tong-guo-fen-ge-fu-fen-ge-zi-fu-chuan
> 
> perex:
> 	- Rozdělení řetězce na více částí podle oddělovače.
> 	- 根据分离器将链条分割成多个部分。
> 
> publicationDate: '2019-11-26 11:39:36'
> mainCategoryId: f1b0be9b-de09-4c8a-8338-dc285bed95ec
> sourceContentHash: '66725772be4aae0df8af399e7ce2ba07'

Explode用于轻松地用分隔符分割一个字符串。

- 它将各个结果作为一个从零开始的数组返回。
- 你不能插入一个数组，只有字符串被输入。
- 在解析过程中不能改变定界符，不能选择多个定界符。

| 支持 | PHP 4及更高版本 |
|---------------|-----------------|
| 简要描述 | 通过分隔符将字符串分割成一个数组。
| 要求 | 无
| 注意 | 不能插入一个数组，只能插入一个字符串。

通常我们需要根据一些简单的规则来分割一个字符串。例如，一个以逗号分隔的数字列表。

explode()函数在这方面很好，它把分隔符（分隔字符串）作为第一个参数，把数据本身作为第二个参数。

```php
$cisla = '3, 1, 4, 1, 5, 9';
$parser = explode(',', $cisla);

foreach ($parser as $cislo) {
	echo $cislo . '<br>';
	// 在这里我们可以进一步处理这些数字
}
```

但是，如果数字是由逗号隔开的，但周围有空格怎么办？

解决办法是通过最小的普通子串进行解析，然后删除其周围不需要的字符（空格和其他空白）。

```php
$cisla = '3, 1,4, 1 , 5 ,9';
$parser = explode(',', $cisla);

foreach ($parser as $cislo) {
     echo trim($cislo) . '<br>';
     // 在这里我们可以进一步处理这些数字
}
```

在这种情况下，`trim()`函数优雅地去除字符周围的空白（空格、制表符、换行符...），只给出干净的数据。

限制，限制解析成数组的实体数量
--------------------------

> 提示：对于许多例子，explode()并不适合，使用正则表达式要好得多。

然而，我们经常只想解析到某一距离的数据，第三个（可选）参数limit可以用于这一目的。

例如，我们有以冒号分隔的结构化数据，我们想获得第一个冒号之后的内容，而忽略其他冒号。
例子。

```php
$cas = '格式："j.n.Y - H:i"';
```

如果我们只将该字符串解析为。

```php
$parser = explode(':', $cas);
```

我们将得到这3个子字符串（在其他情况下可能有更多的子字符串）。

```php
'格式'
'"j.n.Y - H'
'i"'
```

因此，我们设置了一个限制，以获得多少个元素（可能所有其他的元素将被附加到最后一个元素的末尾）。

```php
$parser = explode(':', $cas, 2);

//回来了。
echo $parser[0]; // 格式
echo $parser[1]; // "j.n.Y - H:i"
```

> **注意：**不需要的引号可以从字符串中删除，例如，通过使用`trim()`函数。

```php
echo trim($parser[1], '"'); // 第二个参数指定要删除的字符地图
```

之间，在两个字符串之间获得一个字符串
--------------------------

通常我们需要得到一个被另外两个字符串所包围的字符串。在PHP中没有直接的函数，但我们可以自己编写。

```php
function between(string $left, string $right, string $data): string
{
   $l = explode($left, $data);
   $r = explode($right, $l[1]);

   return $r[0];
}
```

正则表达式
--------------------------

使用<a href="/regex">正则表达式</a>可以实现更优雅的分割和处理字符串，我在另一个页面中讨论。

类似的功能
--------------------------

- <a href="/function-implode">Implode()</a> - 将一个数组串联成一个字符串

IP地址解析的例子
--------------------------

```php
$ip = '10.0.0.138';
$parser = explode('.', $ip);
echo $parser[0]; //打印出 "10"
echo $parser[1]; //打印出 "0"。
```

`$ip`变量包含一个输入字符串，根据`.`分隔符进行解析，返回是一个数组。除非指定限制，否则解析会一直持续到字符串的末尾。

参数
--------------------------

| | 类型 | 描述
|---|--------|------|
| 1 |字符串 | 分离字符串。
|2 |字符串 |解析的字符串。
| 3 | int | 解析限制。这是一个可选的参数。例子。

```php
$text = 'PHP是我最喜欢的语言!';
$parser = explode('', $text, 1);

echo $parser[0]; //打印出第一个字
echo $parser[1]; //打印其余的文本
echo $parser[2]; //没有输出任何东西，因为已经设置了一个限制!
```

返回值
--------------------------

返回值是一个包含解析过的字符串的数组。

指数从零到`X`编号，除非指定限制。

与早期版本的不同之处
--------------------------

| PHP版本 | 描述 |
|-----------|-------|
| 5.1.0 | 增加了对通行证负数限制的支持。
| 4.0.1 | 增加了可选的**limit**参数。

提示和说明
--------------------------

当使用负的**limit**时，会给出从字符串末端开始的元素数量。

例子。

```php
$str = '一、二、三、四';

// 正极限
print_r(explode('|', $str, 2));

// 负数限制（自 PHP 5.1 起）。
print_r(explode('|', $str, -1));
```

以下字段将被返回。

```php
Array
(
    [0] => one
    [1] => two|three|four
)

Array
(
    [0] => one
    [1] => two
    [2] => three
)
```
